# Хороші практики у тестуванні

Тестування є ключовим етапом у забезпеченні якості програмного забезпечення. Дотримання хороших практик допомагає створювати тести, які є ефективними, стабільними та простими в підтримці. Нижче наведено список рекомендацій для покращення підходів до тестування.

## 1. Пишіть тести для найбільш важливих частин системи (бізнес-логіки)
Зосередьте зусилля на тестуванні найбільш критичних частин системи, які безпосередньо впливають на бізнес-функціонал.

**Чому це важливо:**
- Забезпечує стабільність ключових компонентів.
- Знижує ризик критичних помилок у виробничому середовищі.

## 2. Використовуйте юніт-тести для покриття граничних випадків та складних сценаріїв
Юніт-тести ефективно перевіряють різні сценарії роботи окремих модулів, включаючи граничні випадки та рідкісні ситуації.

**Чому це важливо:**
- Дозволяє виявити помилки на ранньому етапі.
- Підвищує впевненість у правильності роботи кожного модуля.

**Приклад:**
```kotlin
@Test
fun `should return error for input out of range`() {
    val result = systemUnderTest.processInput(-1)
    assertEquals("ERROR", result)
}
```

## 3. Створюйте тести, які перевіряють кінцевий результат, а не процес виконання
Тести мають перевіряти очікувану поведінку та результати роботи системи, а не деталі її виконання.

**Чому це важливо:**
- Підвищує стійкість тестів до змін у реалізації.

**Приклад:**
```kotlin
@Test
fun `should return correct total amount`() {
    val total = cart.calculateTotal()
    assertEquals(100.0, total)
}
```

## 4. Розділяйте бізнес-логіку та побічні ефекти для спрощення тестування
Розділення логіки та взаємодії з зовнішніми залежностями спрощує написання та підтримку тестів.

**Чому це важливо:**
- Зменшує складність тестування.
- Полегшує ізоляцію та модульність коду.

## 5. Використовуйте підхід 'білого ящика' для аналізу тестів а 'чорного ящика' для написання тестів
Використовуйте утиліти, що показують покриття коду для виявлення непротестованих частин програми,
але потім тестуйте їх так, немов вам нічого не відомо про внутрішню структуру цього коду.


**Чому це важливо:**
- Дозволяє зосередитися на перевірці поведінки системи.
- Забезпечує гнучкість до змін у внутрішній реалізації.

## 6. Забезпечуйте ізоляцію тестів, щоб уникнути залежностей між ними
Кожен тест має бути незалежним від інших і виконуватись у контрольованому середовищі.

**Чому це важливо:**
- Гарантує відтворюваність тестів.
- Зменшує труднощі з пошуком проблем у разі їхнього виникнення.

**Приклад:**
```kotlin
@BeforeEach
fun setup() {
    database.clear()
}
```

## 7. Тестові назви повинні відображати поведінку, а не методи
Іменування тестів має чітко описувати перевірювану поведінку, що робить їх більш зрозумілими для інших розробників.

**Чому це важливо:**
- Полегшує розуміння мети тесту.
- Допомагає швидко знаходити потрібні тести.

**Приклад:**
```kotlin
@Test
fun `should apply discount for VIP customers`() {
    // Тестуємо знижку для VIP-клієнтів
}
```

## 8. Підтримуйте чіткий та мінімалістичний дизайн тестів
Тести мають бути простими та зосередженими на перевірці одного аспекту поведінки.

**Чому це важливо:**
- Полегшує читання та підтримку.
- Зменшує ймовірність помилок у тестах.

**Приклад:**
```kotlin
@Test
fun `should return default value if input is null`() {
    val result = systemUnderTest.processInput(null)
    assertEquals("DEFAULT", result)
}
```

## 9. Використовуйте в тестах окремий набір літералів і констант
Не покладайтеся на значення з робочого коду. Замість цього створюйте у тестах контрольні точки, незалежні від реалізації коду.

## 10. Уникайте тавтологічних тестів
Тести повинні перевіряти результат, а не дублювати логіку алгоритму.

## 11. Виносьте час у вигляді явної залежності
Час повинен передаватися у вигляді параметра або через сервіс, а не бути частиною неявного контексту.

**Приклад:**
```kotlin
@Test
fun `should calculate age based on birth date`() {
    // Підготовка
    val birthDate = LocalDate.of(1990, 1, 1)
    val currentDate = LocalDate.of(2024, 1, 1)
    val expectedAge = 34

    // Дія
    val actualAge = calculateAge(birthDate, currentDate)

    // Перевірка
    assertThat(actualAge).isEqualTo(expectedAge)
}
```

## 12. Використовуйте шаблон Object Mother для підготовки даних
Object Mother забезпечує створення об'єктів для тестів у зручному форматі.

**Приклад:**
```kotlin
object TestDataMother {
    fun createUser(name: String = "Користувач", age: Int = 25): User {
        return User(name, age)
    }
}

@Test
fun `should create user correctly`() {
    // Підготовка
    val user = TestDataMother.createUser(name = "Іван")

    // Дія
    val result = user.isAdult()

    // Перевірка
    assertThat(result).isTrue()
}
```

## 13.Використовуйте fluent-інтерфейс для перевірки
Fluent інтерфейс робить перевірки читабельними й легкими для розуміння.

**Приклад:**
```kotlin
    @Test
fun `should verify multiple order properties with fluent interface`() {
    // Підготовка
    val order = Order(id = 5, items = listOf("item1", "item2", "item3"), total = 150.0)

    order.items should (haveSize(3) and containExactlyInAnyOrder("item1", "item2", "item3"))
    order.total.shouldBeExactly(150.0)
    order.isValid() shouldBe true
}
```
