# Погані практики у тестуванні

Тестування є невід'ємною частиною розробки якісного програмного забезпечення, однак неправильні підходи можуть звести нанівець всі зусилля. Нижче наведено поширені погані практики у тестуванні, яких слід уникати.

## 1. Перевірка деталей реалізації замість поведінки системи
Тестування має бути зосереджене на перевірці очікуваної поведінки системи, а не на внутрішній реалізації. Зміни у внутрішніх деталях можуть ламати тести, навіть якщо поведінка системи залишилась незмінною.

**Чому це погано:**
- Зменшує гнучкість коду.
- Ускладнює рефакторинг.

**Приклад:**
```kotlin
@Test
fun `should verify internal method call`() {
    val mockService = mock(Service::class.java)
    val sut = SystemUnderTest(mockService)

    sut.performAction()

    verify(mockService).internalHelperMethod() // Перевірка внутрішнього виклику
}
```

## 2. Залежність тестів від конкретної структури даних або класів
Тести, прив'язані до конкретної реалізації, можуть бути нестійкими до змін структури коду.

**Чому це погано:**
- Ускладнює зміну структури даних або рефакторинг.
- Знижує повторне використання тестів.

## 3. Розширення публічного API заради зручності тестування
Додавання методів чи атрибутів до публічного API лише для тестів порушує інкапсуляцію та ускладнює підтримку.

**Чому це погано:**
- Порушує принципи дизайну.
- Може призвести до використання цих методів в робочому коді.

## 4. Використання моків для перевірки внутрішніх взаємодій
Моки мають застосовуватися лише для перевірки взаємодій між компонентами, але не для тестування внутрішньої логіки.

**Чому це погано:**
- Робить тести крихкими.
- Ускладнює рефакторинг внутрішніх методів.

## 5. Прив'язка тестів до нестабільних залежностей
Залежність тестів від часу, випадкових даних чи зовнішніх систем робить їх нестабільними.

**Чому це погано:**
- Тести можуть падати через фактори, не пов'язані з кодом.

**Приклад:**
```kotlin
@Test
fun `should fail depending on current time`() {
    val currentHour = LocalTime.now().hour
    assertTrue(currentHour < 12) // Тест нестабільний
}
```

## 6. Змішування тестового та робочого коду
Змішування логіки тестів із робочим кодом робить підтримку складнішою.

**Чому це погано:**
- Ускладнює розуміння та модифікацію коду.
- Збільшує ризик помилок у робочому коді.

## 7. Тестування приватних методів напряму
Приватні методи мають тестуватися через публічний API, оскільки вони є деталями реалізації.

**Чому це погано:**
- Порушує інкапсуляцію.
- Робить тести залежними від деталей реалізації.

## 8. Перевантажені тести з кількома перевірками та складною логікою
Тести мають бути простими, зосередженими на перевірці одного аспекту поведінки.

**Чому це погано:**
- Ускладнює розуміння результатів тесту.
- Збільшує ймовірність помилок у тестах.

**Приклад:**
```kotlin
@Test
fun `should test multiple behaviors`() {
    val result = systemUnderTest.doSomething()
    assertEquals("expectedValue", result.value)
    assertTrue(result.isValid)
    assertNotNull(result.timestamp)
}
```

---

**Висновок:** Уникнення перелічених поганих практик допоможе зробити ваші тести надійнішими, простішими в підтримці та ефективнішими для забезпечення якості програмного забезпечення.

