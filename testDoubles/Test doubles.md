### Тестові заглушки: види, призначення та використання

Тестові заглушки (“test doubles”) — це інструменти, що допомагають ізолювати тестовану систему, замінюючи її залежності. Вони дають змогу емулювати поведінку об’єктів або залежностей для спрощення тестування.

#### Основні види тестових заглушок:

1. **Пустишка (Dummy):**
    - **Опис:** Найпростіша форма заглушки, яка не впливає на результат. 
Це може бути просте зашите в код значення: null, довільне строка або обєкт який не виконує ніяких функцій.
    - **Призначення:** Використовується для задоволення сигнатури методу, якщо залежність не бере участі в логіці тесту.
    - **MockK функція:** `mockk(relaxed = true)`
    - **Приклад:**
      ```kotlin
      val dummyLogger = mockk<Logger>(relaxed = true)
      val service = MyService(dummyLogger)
      service.doSomething()
      ```

2. **Заглушка (Stub):**
    - **Опис:** Заглушка повертає передбачувані значення залежно від сценарію, емулюючи вхідні дані.
    - **Призначення:** Забезпечує тестовану систему необхідними даними для виконання тесту.
    - **MockK функція:** `every { ... } returns ...`
    - **Приклад:**
      ```kotlin
      val stubService = mockk<MyService> {
          every { fetchData() } returns "Stubbed data"
      }
      assertEquals("Stubbed data", stubService.fetchData())
      ```

3. **Шпигун (Spy):**
    - **Опис:** Заглушка, яка дозволяє виконувати реальну логіку об'єкта, який тестується, але одночасно стежить за тим, які методи викликалися і з якими параметрами.
    - **Призначення:** Перевірка того, як об'єкт використовується в тестованій системі. Зберігає реальну логіку класу без потреби дублювати її в тестах. Шпигуни допомагають перевикористовувати код у фазі перевірок, скорочуючи таким чином розмір і покращуючи читабельність тестів.
    - **MockK функція:** `spyk()`
    - **Приклад:**
      ```kotlin
      val spyService = spyk<MyService>()
      spyService.performAction()
      verify { spyService.performAction() }
      ```

4. **Підставний об’єкт (Mock):**
    - **Опис:** Це шпигун, який додатково може перевіряти очікування, наприклад, виклик із певними параметрами.
    - **Призначення:** Перевіряє взаємодії між тестованою системою і залежностями.
    - **MockK функція:** `mockk()` та `verify { ... }`
    - **Приклад:**
      ```kotlin
      val mock = mockk<MyService>()
      every { mock.performAction(any()) } returns Unit
      mock.performAction("Test")
      verify { mock.performAction("Test") }
      ```

5. **Імітація (Fake):**
    - **Опис:** Повноцінна заміна реального об’єкта. Може містити спрощену або альтернативну логіку. Зазвичай створюється для заміни залежностей яких ще не існує.
    - **Призначення:** Використовується для тестування складних систем, наприклад, заміщення бази даних у пам’яті.
    - **MockK функція:** Реалізація вручну
    - **Приклад:**
      ```kotlin
      class FakeDatabase : Database {
          private val data = mutableListOf<String>()
          override fun insert(value: String) { data.add(value) }
          override fun query(): List<String> { return data }
      }
      val fakeDb = FakeDatabase()
      fakeDb.insert("Test")
      assertEquals(listOf("Test"), fakeDb.query())
      ```

#### Основні принципи використання тестових заглушок:

- **Не перевіряйте взаємодії зі стабами:** Це деталі реалізації, які не впливають на кінцевий результат тесту.
- **Моки для зовнішніх залежностей:** Вони підходять для перевірки зовнішніх взаємодій із системами.
- **Шпигуни для деталізації:** Використовуються для моніторингу дій над об’єктами всередині системи.
- **Фейки для складних залежностей:** Наприклад, заміна бази даних чи API, які важко налаштувати для тестів.

#### Відмінності між типами заглушок:

- **Пустишки:** Тільки задовольняють сигнатуру методу.
- **Стаби:** Повертають необхідні дані для виконання тесту.
- **Шпигуни:** Відстежують виклики й повертають значення.
- **Моки:** Перевіряють очікувані виклики.
- **Фейки:** Замінюють об’єкти зі спрощеною логікою або альтернативною реалізацією.

#### Загальні рекомендації:

- Тестові заглушки допомагають створювати ізольовані та надійні тести.
- Використовуйте правильний тип заглушки залежно від цілей тесту.
- Зведіть до мінімуму зв'язок між тестами і реалізацією залежностей, щоб зменшити хрупкість тестів.

